#import "@preview/finite:0.5.0": automaton
#import "@preview/finite:0.5.0"

#set text(15pt, font:("Libertinus Serif", "Source Han Serif SC"))
= L0.2
== 1
+ 这个集合包含了所有的正奇数
+ 这个集合包含了所有的偶数
+ 这个集合包含了 $NN$ 中所有 $6$ 的倍数
+ 这个集合包含了所有 01 回文字符串
+ 这个集合是一个空集

== 2
+ ${1, 10, 100}$
+ ${n in NN | n > 5}$
+ ${0, 1, 2, 3, 4}$
+ ${"aba"}$

== 3
+ $A$ 不是 $B$ 的子集, 但是 $B$ 是 $A$ 的子集.
+ $A union B = {x, y, z}$, $A inter B = {x, y}$, $A times B = {(x, x), (x, y), (y, x), (y, y), (z, x), (z, y)}$, $cal(P)(B) = {emptyset, {x}, {y}, {x, y}}$

== 4
#image("tcs-1-pic1.png", width:30%)

每一个顶点的度数为 *1*: 3; *2*: 3; *3*: 2; *4*: 2.

= L0.3 - L1.2
== 1
假设一个含有 $N$ 的顶点的图的每一个顶点的度数都不同, 而一个顶点的度数至少为 $0$, 最多为 $N-1$, 所以这 $N$ 个顶点的度数只能是 $0, 1, 2, ..., N-1$ 这 $N$ 个数. 但是如果有一个顶点的度数为 $N-1$, 那么就不可能有一个顶点的度数为 $0$, 因为这个度数为 $N-1$ 的顶点已经和图中的所有其他顶点相连了. 所以假设不成立, 至少有两个顶点的度数是相同的.

== 2
如果素数只有有限个, 那么一定有最大的一个素数, 记为 $p$. 我们考虑所有小于等于 $p$ 的素数 $p_1, p_2, ..., p_k$, 那么 $N = p_1 times p_2 times ... times p_k + 1$ 一定也是素数, 因为 $N$ 不能被任何一个素数 $p_1, p_2, ..., p_k$ 整除. 但是 $N > p$, 这和 $p$ 是最大的素数矛盾, 所以素数有无穷多个.

== 3
+ 设 $S(n) = 1/2 n(n+1)$, 当 $n=1$ 时, $S(1) = 1$, 命题成立. 假设当 $n=k$ 时命题成立, 即 $S(k) = 1/2 k(k+1)$, 那么当 $n=k+1$ 时,
  $
  S(k+1) = S(k) + (k+1) = 1/2 k(k+1) + (k+1) = 1/2 (k+1)(k+2)
  $
  所以当 $n=k+1$ 时命题也成立. 根据数学归纳法, 对任意的 $n in NN^+$, 都有 $S(n) = 1 + 2 + ... + n$.

  再设 $C(n) = 1/4 n^2(n+1)^2$, 当 $n=1$ 时, $C(1) = 1$, 命题成立. 假设当 $n=k$ 时命题成立, 即 $C(k) = 1/4 k^2(k+1)^2$, 那么当 $n=k+1$ 时,
  $
  C(k+1) & = 1/4(k+1)^2(k+2)^2 \
         & = 1/4(k+1)^2 (k^2 + 4k + 4) \
         & = 1/4(k+1)^2 k^2 + (k+1)^2 k + (k+1)^2 \
         & = C(k) + (k+1)^3
  $
  所以当 $n=k+1$ 时命题也成立. 根据数学归纳法, 对任意的 $n in NN^+$, 都有 $C(n) = 1^3 + 2^3 + ... + n^3$.

== 4
+ $M_1$ 的起始状态为 $q_1$, 接受状态集为 ${q_2}$; $M_2$ 的起始状态为 $q_1$, 接受状态集为 ${q_1, q_4}$.
+ $M_1$ 的状态序列为 $q_1 q_2 q_3 q_1 q_1$; $M_2$ 的状态序列为 $q_1 q_1 q_1 q_2 q_4$.
+ $M_1$ 不接受, $M_2$ 接受.
+ $M_1$ 不接受, $M_2$ 接受.

== 5
#automaton(
  (
    q1: (q1:"u", q2:"d"),
    q2: (q1:"u", q3:"d"),
    q3: (q2:"u", q4:"d"),
    q4: (q3:"u", q5:"d"),
    q5: (q4:"u", q5:"d"),
  ),
  initial: "q3",
  final: ("q3",),
)

== 6
=== 
1. $w$ 从 $1$ 开始且以 $0$ 结束

#automaton(
  (
    q1: (q2:"0", q3:"1"),
    q2: none,
    q3: (q4:"0", q3: "1"),
    q4: (q4:"0", q3: "1")
  ),
  initial: "q1",
  final: ("q4",),
)

2. $w$ 含有至少 $3$ 个 $1$

#automaton(
  (
    q1: (q1:"0", q2:"1"),
    q2: (q2:"0", q3:"1"),
    q3: (q3:"0", q4:"1"),
    q4: (q4:"0,1")
  ),
  initial: "q1",
  final: ("q4",),
)

3. $w$ 含有子串 $0101$

#automaton(
  (
    q1: (q1:"1", q2:"0"),
    q2: (q1:"0", q3:"1"),
    q3: (q1:"1", q4:"0"),
    q4: (q1:"0", q5:"1"),
    q5: (q5:"0,1")
  ),
  initial: "q1",
  final: ("q5",),
)

4. $w$ 的长度不小于 $3$ 且第 $3$ 个符号为 $0$

#automaton(
  (
    q1: (q2:"0,1"),
    q2: (q3:"0,1"),
    q3: (q4:"0", q5:"1"),
    q4: (q4:"0,1"),
  ),
  initial: "q1",
  final: ("q4",),
  layout: finite.layout.custom.with(positions: (q5: (12, -2)))
)

5. $w$ 的奇数位置均为 $1$

#automaton(
  (
    q1: (q2:"0", q3:"1"),
    q2: none,
    q3: (q1: "0,1")
  ),
  initial: "q1",
  final: ("q1","q3"),
  layout: finite.layout.custom.with(positions: (q2: (4, -2)))
)

== 5
下面每个语言都是两个简单语言的交. 构造识别这些语言的DFA:

*1. $w$ 至少含有 $3$ 个 $a$ 和至少 $2$ 个 $b$*

先构建一个DFA $M_("count")$ 来识别含有至少 $n$ 个某个符号的字符串, 假设这个符号为 x, y 代表字母表中除 x 以外的其他符号, 那么 $M_("count")$ 的状态转移图为:

#automaton(
  (
    q0: (q0:"y", q1:"x"),
    q1: (q1:"y", q2:"x"),
    q2: (q2:"y", q3:"x"),
    q3: (q3:"y", qn:"x"),
    qn: (qn:"x, y")
  ),
  initial: "q0",
  final: ("qn",),
  labels: (
    "qn": $"q"_n$,
    "q3": $dots$
  )
)

然后构建两个DFA, $M_a$ 识别含有至少 $3$ 个 $a$ 的字符串, $M_b$ 识别含有至少 $2$ 个 $b$ 的字符串. 最后通过笛卡尔积构造法构造出识别这两个语言交的 DFA $M$, 具体而言:
- $Q = Q_a times Q_b$
- $q_0 = (q_(0a), q_(0b))$
- $F = {(q_a, q_b) | q_a in F_a, q_b in F_b}$
- $delta ((q_a, q_b), x) = (delta_a(q_a, x), delta_b(q_b, x))$

*2. $w$ 含有偶数个 $a$ 和 $1$ 个或 $2$ 个 $b$*

同样先构建一个DFA $M_("mod")$ 来识别含有 $n space (mod 2)$ 个某个符号的字符串, 假设这个符号为 x, y 代表字母表中除 x 以外的其他符号, 那么 $M_("mod")$ 的状态转移图为:

#grid(
  columns: 2,
  gutter: 2cm,
  figure(
    automaton(
      (
        q0: (q0:"y", q1:"x"),
        q1: (q1:"y", q0:"x"),
      ),
      initial: "q0",
      final: ("q0",),
    ),
    caption: $n = 0 space (mod 2)$
  ),
  figure(
    automaton(
      (
        q0: (q0:"y", q1:"x"),
        q1: (q1:"y", q0:"x"),
      ),
      initial: "q0",
      final: ("q1",),
    ),
    caption: $n = 1 space (mod 2)$
  ) 
)

假设我们已经基于 $M_("count")$ 构造了 $M_("b1")$ 和 $M_("b2")$ 来分别识别含有 $1$ 个和 $2$ 个某个符号的字符串, 那么我们可以通过并集构造法来构造出识别含有 $1$ 个或 $2$ 个某个符号的字符串的DFA $M_("b1or2")$, 具体而言:

- $Q = Q_("b1") times Q_("b2")$
- $q_0 = (q_(0 b 1), q_(0 b 2))$
- $F = {(q_(b 1), q_(b 2)) | q_(b 1) in F_(b 1) or q_(b 2) in F_(b 2)}$
- $delta ((q_(b 1), q_(b 2)), x) = (delta_(b 1)(q_(b 1), x), delta_(b 2)(q_(b 2), x))$

然后我们可以通过 *1.* 中的方式构造 $M_("mod")$ 和 $M_("b1or2")$ 的笛卡尔积来识别这两个语言交的DFA.

*3. $w$ 从 $a$ 开始且最多有 $1$ 个 $b$*

直接构造

#automaton(
  (
    q1: (q2:"a", q3:"b"),
    q2: (q2:"a", q4:"b"),
    q3: none,
    q4: (q4:"a", q5:"b"),
    q5: none
  ),
  initial: "q1",
  final: ("q2", "q4"),
  layout: finite.layout.custom.with(positions: (
    q1: (0, 0),
    q2: (3, 0),
    q4: (6, 0),
    q3: (0, 3),
    q5: (6, 3)
  ))
)

*4. $w$ 含有奇数个 $a$ 并且以 $b$ 结尾*

含有奇数个 $a$ 的 DFA 可以通过 *2.* 中的 $M_("mod")$ 构造, 以 $b$ 结尾的 DFA 可以直接构造:

#automaton(
  (
    q1: (q1:"a", q2:"b"),
    q2: (q1:"a", q2:"b")
  ),
  initial: "q1",
  final: ("q2",),
)

然后我们可以通过 *1.* 中的方式构造这两个语言交的 DFA.


*5. $w$ 的长度为偶数且含有奇数个 $a$*

含有奇数个 $a$ 的 DFA 可以通过 *2.* 中的 $M_("mod")$ 构造, 长度为偶数的 DFA 可以直接构造:

#automaton(
  (
    q1: (q2:"a, b"),
    q2: (q1:"a, b")
  ),
  initial: "q1",
  final: ("q2",),
)

然后我们可以通过 *1.* 中的方式构造这两个语言交的 DFA.

== 6
下述每个语言都是一个简单语言的补. 构造识别这些语言的DFA:

*1. $w$ 不含有 $a b$ 子串*

先构造识别含有任意子串 $x_1 x_2 dots x_n$ 的DFA $M_("sub")$
#automaton(
  (
    q1: (q1:"y", q2:"x1"),
    q2: (q1:"y", q3:"x2"),
    q3: (q1:"y", q4:"x3"),
    q4: (q1:"y", q5:"x4"),
    q5: (q5:"x1 x2, ..., xn, y")
  ),
  initial: "q1",
  final: ("q5",),
  labels: (
    "y": $"y"$,
    "q5": $dots$,
    q1-q2: $x_1$,
    q2-q3: $x_2$,
    q3-q4: $x_3$,
    q4-q5: $x_4$,
    q5-q5: $x_1x_2 ... x_n, y$,
    q1-q1: $y$,
    q2-q1: $y$,
    q3-q1: $y$,
    q4-q1: $y$
  )
)

然后我们只需要令新的 DFA 的接受状态集为原 DFA 的非接受状态集, 即 $F = Q - F_("sub")$, 就可以识别不含有 $a b$ 子串的语言.

*2. $w$ 既不含有 $a b$ 子串, 也不含有 $b a$ 子串*

先通过 $M_("sub")$ 构造识别含有 $a b$ 子串的DFA $M_("ab")$, 再通过 $M_("sub")$ 构造识别含有 $b a$ 子串的DFA $M_("ba")$. 然后通过并集构造法构造出识别这两个语言并的 DFA $M_("aborba")$, 具体而言:
- $Q = Q_("ab") times Q_("ba")$
- $q_0 = (q_(0 "ab"), q_(0 "ba"))$
- $F = {(q_("ab"), q_("ba")) | q_("ab") in F_("ab") or q_("ba") in F_("ba") }$
- $delta ((q_("ab"), q_("ba")), x) = (delta_("ab")(q_("ab"), x), delta_("ba")(q_("ba"), x))$

再利用 *1.* 中的方法构造出识别这两个语言的并的补的 DFA.

*3. $w$ 不是在 $a^* b^*$ 中的字符串*

先构造识别在 $a^* b^*$ 中的字符串的DFA:

#automaton(
  (
    q1: (q2:"a", q3: "b"),
    q2: (q2:"not b", q4: "b"),
    q4: none,
  ),
  initial: "q1",
  final: ("q4",),
  layout: finite.layout.custom.with(positions: (
    q1: (0, 0),
    q3: (0, -3),
    q2: (3, 0),
    q4: (6, 0)
  ))
)

然后再利用 *1.* 中的方法构造出识别这个语言的补的 DFA.

*4. $w$ 是恰好不含 $2$ 个 $a$ 的任意串*

我们先构造一个识别恰好含有 $2$ 个 $a$ 的任意串的DFA:
#automaton(
  (
    q1: (q1:"not a", q2:"a"),
    q2: (q2:"not a", q3:"a"),
    q3: (q4:"a", q3:"not a")
  ),
  initial: "q1",
  final: ("q3",),
)

然后再利用 *1.* 中的方法构造出识别这个语言的补的 DFA.