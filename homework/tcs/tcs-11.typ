
#import "@preview/showybox:2.0.4": showybox
#import "@preview/equate:0.3.2": equate
#import "@preview/ilm:1.4.1": *
#import "@preview/finite:0.5.0": automaton
#import "@preview/finite:0.5.0"
#import "@preview/tdtr:0.3.0": *

#set text(font: ("Libertinus Serif", "Source Han Serif SC"))

#show heading.where(level: 1): set text(navy.lighten(0%))
#show heading.where(level: 2): set text(navy.lighten(20%))
#show heading.where(level: 3): set text(navy.lighten(40%))

#show ref: it => {
  text(purple, it)
}

#show: ilm.with(
  title: [理论计算机科学作业 L3.3 - L3.7],
  date: datetime.today(),
  author: "潘天麟 2023K8009908023",
  table-of-contents: none,
)

#show: equate.with(breakable: true, sub-numbering: true)
#set math.equation(numbering: "(1.1)")

#set heading(numbering: "1.1.1")
#set page(numbering: "1")

#set text(14pt)
#show raw: set text(font: "Maple Mono NF", size: 12pt)

#let frameSettings = (
  border-color: navy,
  title-color: navy.lighten(30%),
  body-color: navy.lighten(95%),
  footer-color: navy.lighten(80%),
)

#let colMath(x, color) = text(fill: color)[$#x$]

#let prob(title, body) = showybox(
  title: title,
  frame: frameSettings,
  body,
)

#prob(
  "T1",
)[
  当我们在证明一个语言是图灵可识别的当且仅当有枚举器枚举它, 为什么不能用下面更简单的算法作为充分性证明
  1. 对于 $i = 1, 2, 3, ...$, 重复以下步骤
  2. 在 $s_i$ 上运行 $M$
  3. 如果 $M$ 接受 $s_i$, 则输出 $s_i$
]

因为这种算法有可能陷入死循环. 如果 $s_i$ 不能被 $M$ 接受且在 $M$ 上不停机, 那么这个算法就永远无法进行到 $s_(i+1)$. 因此这种算法不能保证枚举器 $E$ 能够枚举语言 $L$ 中的所有字符串.


#prob(
  "T2",
)[
  双无限带图灵机(Turingmachne with doubly infinite tape) 与普通图灵机相似, 所不同的是它的带子向左和向右都是无限的. 此带子在开始时, 除了包括输入区域外, 其他都填以空白符, 计算也像通常一样定义, 只是在它向左移动时不会遇到带子的端点. 证明这种类型的图灵机识别图灵可识别语言类.
]

显然, 双无限带图灵机可以模拟普通图灵机. 所以我们只需要证明普通图灵机也可以模拟双无限带图灵机.

我们可以定义一个从双无限带到单无限带的一个映射. 令 $..., C_(-2), C_(-1), C_0, C_1, C_2, ...$ 为双无限带图灵机 $M$ 的方格; $S_0, S_1, S_2, ...$ 为单无限带图灵机 $M'$ 的方格. 我们可以定义一个双射:
$
  C_0 -> S_0, \
  C_1 -> S_1, quad C_(-1) -> S_2 \
  C_2 -> S_3, quad C_(-2) -> S_4 \
  ...
$
也就是说, $f(i) = cases(2i -1 quad & i > 0, -2i quad & i <= 0)$. 在这种映射下, 双无限带图灵机每次移动一格, 普通图灵机就移动两格. 同时我们需要在普通图灵机上维护一个状态记录当前处于 "负" 格还是 "正" 格, 来正确地模拟双无限带图灵机的移动.

因此, 普通图灵机可以模拟双无限带图灵机. 即双无限带图灵机识别图灵可识别语言类.

#prob(
  "T3",
)[
  设 $k$-PDA 表示有 $k$ 个栈的下推自动机. 因此, $0$-PDA 就是一个 NFA, 而 $1$-PDA 就是一个普通 PDA. 由此我们知道 $1$-PDA 比 $0$-PDA 更强大 (即能够识别更大的语言类). 请证明:
  1. $2$-PDA 比 $1$-PDA 更强大.
  2. $3$-PDA 不比 $2$-PDA 更强大.
]

*1.* 显然 $2$-PDA 可以识别所有 $1$-PDA 可以识别的语言. 考虑非 CFL 语言 $L = { a^n b^n c^n | n >= 1 }$, $1$-PDA 无法识别非 CFL 语言, 我们现在证明 $2$-PDA 可以识别这个语言.

先处理 a 段. 每次读入一个 a, 就将其压入栈 $1$. 然后每次读入一个 b, 先从栈 $1$ 中弹出 $a$ 来匹配, 然后压入栈 $2$. 那么如果 b 读完了但是栈 $1$ 中还有 a, 或者栈 $1$ 中没有 a 但是 b 还没读完, 那么我们就拒绝. 这就保证了 $N("a") = N("b")$.

同理, 后面我们每次读入一个 c, 先从栈 $2$ 中弹出 $b$ 来匹配. 如果栈 $2$ 中找不到 b, 或者栈 $2$ 中还有 b 但是 c 已经读完了, 那么我们就拒绝. 这就保证了 $N("b") = N("c")$.

因此, $2$-PDA 可以识别非 CFL 语言 $L = { a^n b^n c^n | n >= 1 }$. 即 $2$-PDA 比 $1$-PDA 更强大.

*2.* 我们证明 $2$-PDA 的能力和图灵机的能力等价, 如果这成立, 由于不存在比图灵机更强大的自动机, 所以 $3$-PDA 也不比 $2$-PDA 更强大.

我们可以用 $2$-PDA 模拟图灵机. 一台图灵机拥有一条无限长的纸带和一个读写头. 我们可以使用 $2$ 个栈来完美模拟这条纸带.
- 栈 $1$: 存储读写头左侧的纸带内容 (栈顶靠近读写头).
- 栈 $2$: 存储读写当前位置及右侧的纸带内容 (栈顶即为当前读写头指向的符号).

那么对于图灵机的几个操作:
- 向左移动读写头: 从栈 $2$ 中弹出栈顶符号, 然后压入栈 $1$.
- 向右移动读写头: 从栈 $1$ 中弹出栈顶符号, 然后压入栈 $2$.
- 读取当前符号: 从栈 $2$ 中弹出栈顶符号.
- 写入符号: 将符号压入栈 $2$.

这样我们就用 $2$-PDA 完美模拟了图灵机. 因此 $2$-PDA 的能力和图灵机的能力等价, 所有 $k$-PDA ($k >= 2$) 的能力和图灵机的能力等价. 因此 $3$-PDA 不比 $2$-PDA 更强大.

#prob(
  "T4",
)[
  给出接受下列语言的线性有界自动机.

  (a). $L = {a^n | n = m^2, m >= 1}$ \
  (b). $L = {a^n | n "is prime"}$ \
  (c). $L = {a^n | n "is not prime"}$ \
  (d). $L = {w w | w in {a, b}^+}$ \
  (e). $L = {w^n | w in {a, b}^+, n >= 1}$ \
  (f). $L = {w w w^R | w in {a, b}^+}$
]

*(a).* 我们可以利用完全平方数的展开
$
  n^2 = 1 + 3 + 5 + ... + (2n - 1)
$

1. 我们的 LBA 先读入第一个 a. 如果此时磁带空了 ($n = 1$), 我们就接受. 否则, 把这个 a 用 $X$ 代替. 引入一个状态 $U in {S_X, S_Y}$, 标记当前为 $U = S_X$
2. 重复如下步骤: 如果 $U = S_X$, 则从当前读写头往左找 $X$. 每次找到一个 $X$, 我们就把 $X$ 序列后的第一个 a 标记为 $Y$, 依次类推, 前面有多少个 $X$, 就把多少个 $a$ 替换为多少个 $Y$. 直到读写头碰上第一个非 $X$ 的符号. 此时再往右扫描, 找到一个 a, 然后把连续的两个 a (包括这个 a) 用 $Y$ 代替. 令 $U = S_Y$; 如果 $U = S_Y$, 也有类似的处理, 只是把 $Y$ 和 $X$ 反过来.
3. 如果在 2. 中出现了找不到一个对应的 a 来完成需要的标记, 则拒绝. 否则, 重复 2. 直到磁带空了. 如果磁带空了, 则接受.

*(b).* 先引入 LBA 的多道技术. 在 LBA 中, 我们可以把字母表扩展为 $Sigma times {1, 2, 3, ...}$, 其中 $Sigma$ 是原始字母表, $1, 2, 3, ...$ 是新的符号. 这就把 LBA 的每一格的信息容量增大了.

现在我们在逻辑上, 把 LBA 的第一道保留原输入, 第二道用来记录除数.

1. 特例: 若 $n=0, 1$, 则拒绝;若 $n=2$, 则接受.
2. 在第二道上标记长度为 2 的区域作为初始除数 $k = 2$.
3. 重复如下循环:
  - 尝试用当前的 $k$ 去 "平铺" 整个长度 $n$. 即从左到右, 每隔 $k$ 个符号做一个标记.
  - 如果刚好铺满 (没有剩余且刚好到末尾), 说明 $n$ 能被 $k$ 整除, $n$ 是合数, 拒绝.
  - 如果不能整除 (有余数)则将除数 $k$ 增加 1 (在第二道上把标记长度加 1).
4. 如果除数 $k$ 增加到了 $n$ 且之前都没有发生整除, 则说明 $n$ 是素数, 接受.

*(c).* 和 (b) 类似, 只是把拒绝和接受的逻辑反一下.

*(d).*
1. 引入两个指针 (如用 $A$ 表示被标记的 $a$ 的指针, $B$ 表示被标记的 $b$ 的指针) 从两端向中间扫描. 如果 $A$ 和 $B$ 相遇且都指向同一个符号, 则长度为奇数, 拒绝. 否则进入 2.

2. 重置读写头. 指针 1 指向开头, 指针 2 指向中点后第一个字符. 比较指针 1 和指针 2 的内容, 如果相等, 则拒绝. 如果相同, 两个指针同时右移一位, 继续比较. 如果直到末尾都相同, 则接受.

*(e).* 考虑到 $n = 1$ 的情况, 只要输入字符串非空, 我们就可以接受. 否则就拒绝.

*(f).*
1. 使用多带技术, 在第二个带子上维护一个长度为 $k$ 的标记, 检查 $3k$ 是否恰好在纸带的最后一个位置, 如果不是, 则拒绝.
2. 现在我们有了一个 $k$, 我们在 $1$, $k + 1$ 上初始化两个指针, 每次比较它们指向的字符是否相等, 如果不相等, 则拒绝; 否则同时向右移动一位, 继续比较. 直到左指针到达 $k + 1$ 的位置.
3. 现在重新再 $k + 1$ 和 $3k$ 上初始化两个指针, 每次比较它们指向的字符是否相等, 如果不相等, 则拒绝; 左指针向右移动一位, 右指针向左移动一位, 继续比较. 直到左指针到达 $2k + 1$ 的位置.
4. 如果所有检查通过, 接受.

#prob(
  "T5",
)[
  下面的语言都是字母表 ${0, 1}$ 上的语言, 以实现层次的描述给出判定这些语言的图灵机:
  - ${w | w "contains the same number of 0s and 1s"}$
  - ${w | N_0 (w) = 2 N_1(w)}$
  - ${w | N_0 (w) != 2 N_1(w)}$
]

*(a).* 重复扫描磁带, 每次消去 (用特殊字符 $X$ 覆盖) 一个 $0$ 和一个 $1$, 直到磁带上没有 $0$ 或 $1$ 为止.

1. 从左向右扫描磁带, 寻找第一个 $0$. 如果找到了 $0$, 将其标记为 $X$, 然后进入步骤 2. 如果只剩下了 $X$ 或已到达空白符 $E$, 则跳转至步骤 4.
2. 从当前位置或返回起始位置重新开始扫描, 寻找第一个 $1$. 如果找到了 $1$, 将其标记为 $X$, 然后返回带首并跳转至步骤 1. 如果扫描完整个磁带都没有找到 $1$, 说明 $0$ 比 $1$ 多, 拒绝.
3. 如果在步骤 1 中先找到了 $1$, 则去寻找对应的 $0$. 若找不到, 则拒绝.
4. 最后再进行一次全扫描. 如果磁带上只剩下标记符 $X$ 和空白符 $E$, 说明 $0$ 和 $1$ 刚好配对完, 接受; 否则 (还剩下 $0$ 或 $1$) , 拒绝.

*(b).*  和 (a) 类似, 只是这时候每次消去一个 $1$ 时, 要同步消去两个 $0$.

*(c).* 和 (b) 类似, 但是要把原来输出 "接受" 和 "拒绝" 的逻辑反过来.

#prob(
  "T6",
)[
  对于下图所示的 DFA $M$, 回答下列问题, 并且说明理由.

  #align(center)[
    #automaton(
      (
        q1: (q1: "0", q2: "1"),
        q2: (q3: "0,1"),
        q3: (q1: "0", q2: "1"),
      ),
      initial: "q1",
      final: "q1",
      layout: finite.layout.custom.with(positions: (
        q1: (0, 0),
        q2: (3, 0),
        q3: (1.5, -2),
      )),
    )
  ]

  (a). $chevron.l M, 0100 chevron.r in A_"DFA"$? \
  (b). $chevron.l M, 011 chevron.r in A_"DFA"$? \
  (c). $chevron.l M chevron.r in A_"DFA"$? \
  (d). $chevron.l M, 0100 chevron.r in A_"REX"$? \
  (e). $chevron.l M chevron.r in E_"DFA"$? \
  (f). $chevron.l M, M chevron.r in E Q_"DFA"$? \
]

*(a).*: 显然能接受 $q_1 -> q_1 -> q_2 -> q_3 -> q_1$

*(b).* 显然不能接受 $q_1 -> q_1 -> q_2 -> q_3$

*(c).* 不属于, 因为 $M$ 不是一个双元组

*(d).* 不属于. 因为 $M$ 不是一个正则表达式

*(e).* 不属于. 因为 $M$ 可以接受非空串

*(f).* 属于, 因为 $L(M) = L(M)$

#prob(
  "T7",
)[
  考虑一个 DFA 和一个正则表达式是否等价的问题. 将该问题表述为一个语言并证明它是可判定的.
]

我们定义新语言
$
  "EQ"_("DFA", "REX") = { (A, R) | A "is DFA and" R "is REX and" L(A) = L(R) }
$

我们构造一个可以判定 $"EQ"_("DFA", "REX")$ 的图灵机 $M$:

1. 将正则表达式 $R$ 转换为一个等价的有限自动机. 先使用标准的构造法把 $R$ 转化为一个 NFA, 然后再用子集构造法把 NFA 转化为一个 DFA.
2. 运行 $"EQ"_"DFA"$ 的图灵机 $M'$, 判断 $A$ 和 $R$ 是否等价.
3. 如果 $M'$ 接受 $A$ 和 $R$, 则 $M$ 接受 $(A, R)$; 否则 $M$ 拒绝 $(A, R)$.


#prob(
  "T8",
)[
  设 $"ALL"_"DFA" = {chevron.l A chevron.r | A "is DFA and" L(A) = Sigma^*}$. 证明 $"ALL"_"DFA"$ 是可判定的.
]


对于一个定义在字母表 $Sigma$ 上的 DFA $A$, 满足 $L(A) = Sigma^*$ 当且仅当其补语言为空集, 即:
$
  L(A) = Sigma^* <==> overline(L(A)) = emptyset
$
已知 DFA 对补运算封闭, 且 $E_"DFA"$ 是可以判定的. 由此我们可以构造如下图灵机 $M$ 来判定 $"ALL"_"DFA"$:

1. 构造一个新的 DFA $A'$, 使得 $L(A') = overline(L(A))$ (保持 $A$ 的状态集、字母表、转移函数和起始状态不变, 将 $A$ 中所有的接受状态变为非接受状态, 所有的非接受状态变为接受状态)
2. 利用 $E_"DFA"$ 判定 $A'$ 是否为空语言.
3. 如果 $A'$ 是空语言, 则 $M$ 接受 $A$; 否则 $M$ 拒绝 $A$.

#prob(
  "T9",
)[
  设 $A_(epsilon_"CFG") = {chevron.l G chevron.r | G "is a CFG that generates the empty string"}$. 证明 $A_(epsilon_"CFG")$ 是可判定的.
]

给定输入 $G = (V, T, P, S)$, 我们可以构造如下图灵机 $M$:

1. 扫描规则集 $P$, 找到所有形如 $A -> epsilon$ 的规则, 将变量 $A$ 标记为 "可空".
2. 重复执行以下过程, 直到没有新的变量被标记:
  - 检查规则集 $P$ 中的每一个规则 $A -> alpha$, 如果 $alpha$ 中的每个变量都是可空的, 则将 $A$ 标记为 "可空".
3. 如果 $S$ 是可空的, 则 $M$ 接受 $G$; 否则 $M$ 拒绝 $G$.

这个图灵机一定是可停机的, 因为 $G$ 的变量个数和规则个数都是有限的, 所以最多执行有限次循环就能确定 $S$ 是否可空.

#prob(
  "T10",
)[
  对于 CFL $G$中的变元 $A$, 如果它在某个字符串 $w in G$ 的派生中出现, 则称 $A$ 是可用的. 给定一个 CFG $G$和一个变元 $A$, 考虑测试 $A$ 是否为可用的这样一个问题. 将该问题形式化为一个语言, 并证明它是可判定的.
]

设 $G = (V, T, P, S)$ 是一个 CFG, 那么变元 $A in V$ 是可用的, 当且仅当
$
  exists w in T^* "s.t." S -->^* alpha A beta -->^* w, quad alpha, beta in (V union T)^*
$
基于此, 我们可以定义语言
$
  A_"usable" = {chevron.l G, A chevron.r | G "is a CFG and" A "is usable in G"}
$
我们构造一个图灵机 $M$ 来判定 $A_"usable"$, 分成两个阶段

*I. 判定 $A$ 能够产生 $w in T^*$* \
类似于我们上面标记可空符号的方法:
1. 检查所有的产生式 $B -> w$ 其中 $w in T^*$, 标记 $B$ 是 "可产生的"
2. 重复执行以下过程, 直到没有新的变量被标记:
  - 检查规则集 $P$ 中的每一个规则 $B -> alpha$, 如果 $alpha$ 中的每个非终结符都是可产生的, 则将 $B$ 标记为 "可产生的".
3. 检查 $A$ 是否是可产生的, 如果不是, 则拒绝 $G, A$; 否则进入II阶段.

*II. 判定 $A$ 是否是可达的* \
1. 初始化 $S$ 为 "可达的"
2. 重复执行以下过程, 直到没有新的变量被标记:
  - 对于所有已经被标记为可达的变量 $A$, 检查规则集 $P$ 中的每一个规则 $A -> alpha$, 将 $alpha$ 中出现的所有变量标记为 "可达的".
3. 检查 $A$ 是否是可达的, 如果不是, 则拒绝 $chevron.l G, A chevron.r$; 否则 $M$ 接受 $chevron.l G, A chevron.r$.

#prob(
  "T11",
)[
  设
  $
    C_"CFG" = {chevron.l G, k chevron.r | G "is a CFG" \ "and" L(G) "contains" k "distinct strings", \ k >= 0 "or" k = oo}
  $
  证明 $C_"CFG"$ 是可判定的.
]

为了方便起见, 我们先把 $G$ 转化为 CNF, 然后设 $p = 2^abs(V)$, 这里 $V$ 是转化后的变量集合.

*1.* 如果 $k = oo$, 我们只需要判断 $L(G)$ 是否为无限集. 这里我们可以使用 CFL 的泵引理, 如果存在一个字符串 $w in L(G)$ 满足 $p <= |w| < 2 p$, 则 $L(G)$ 是无限集. 如果不存在, 则 $L(G)$ 是有限的.

由于长度在 $p$ 到 $2p$ 之间的字符串是有限的, 且 CFG 的成员资格问题（$w in L(G)$）是可判定的 (如使用 CYK 算法), 我们可以逐一检测, 且保证在有限时间内停机.

因此, 对于 $k = oo$ 的情况, 我们可以运行一个图灵机判断 $L(G)$ 是否为无限集. 如果是, 则接受 $chevron.l G, k chevron.r$, 否则拒绝.

*2.* 如果 $k < oo$, 我们需要判断 $L(G)$ 是否恰好包含 $k$ 个不同的字符串. 我们先运行 1. 中的判断 $L(G)$ 是否为无限集的算法, 如果判断为无限集, 就直接拒绝.

对于一个有限集 $L(G)$, 我们需要有 $forall w in L(G), abs(w) < p$. 如果不然, 则根据 CFL 的泵引理, 它可以无限增长. 所以我们可以遍历所有长度 $< p$ 的字符串 $w$, 判断是否有 $w in L(G)$, 如果是, 那么就让计数器 $N$ 加一.

最后, 如果 $N = k$, 则 $M$ 接受 $chevron.l G, k chevron.r$; 否则拒绝.


